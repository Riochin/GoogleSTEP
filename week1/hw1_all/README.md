# 宿題1
与えられた文字列のAnagramを辞書ファイルから探して返すプログラムを作る
## → アナグラム全てを出力するように改良
自分で何個かテストケースを作って、プログラムが動くか確認


---

# アナグラム辞書プログラムの学習・工夫まとめ

## 目的
- 標準入力やファイルから単語リストを受け取り、アナグラム（文字を並び替えてできる別の単語）を効率的に検索できる辞書を作成・検索するプログラムを作成。

## 主な学習・工夫ポイント

### 1. 入力の扱い
- テストのしやすさを考え、`makeSortedDict(Scanner sc)`では`Scanner`を引数にする設計にした。

### 2. アナグラムの管理方法
- 🌟 HashMapのkeyはユニークな値である必要があったが、完全に忘れてた。ここで一番苦戦！

- アナグラム判定のため、各単語をソートした文字列をキーとし、`HashMap<String, ArrayList<String>>`で管理。
- 例: `apple`と`alppe`はどちらも`aelpp`をキーに持ち、同じリストに格納される。
- 🌟 `computeIfAbsent`を使うことで、キーがなければ新しいリストを作成し、既存ならそのリストに追加できるようにした。
  - この関数は初めて使った。

### 3. 辞書のソートと順序保持
- 🌟 二分探索がうまく行ってない...?ソートして順番にputしているのでなぜ？ってなった時に、HashMapにindexの概念がないことと、LinkedHashMapの存在を初めて知った。

- 辞書のキーをソートし、`LinkedHashMap`に格納することで、キーの順序を保持。
- これにより、出力や二分探索時に安定した順序で処理できる。

### 4. 二分探索による高速検索
- 辞書のキーリストをソートし、二分探索でアナグラムグループの存在を高速に判定。
- 実際のアナグラム候補の取得は`HashMap`から一発でリスト取得できるため、二分探索は存在確認用途。

### 5. コード設計の工夫
- `main`は入出力のみ担当し、ロジックは`static`メソッドに分離。
- テストや拡張がしやすいよう、`solution`や`makeSortedDict`を直接呼び出せる設計に。
- テスト時はファイルから辞書を作成し、`solution`に渡すことで現実的な動作確認が可能。

### 6. その他の学び
- `HashMap`はキーの重複を許さないが、値をリストにすることでアナグラムグループを柔軟に管理できる。
- `computeIfAbsent`やラムダ式、`compareTo`による文字列比較、`sort`の使い方などJavaの標準APIの活用。

## まとめ
- アナグラム辞書の設計・実装を通じて、データ構造の選択やJavaのAPI活用、テストしやすい設計の重要性を学んだ。
- 今後も責務分離や柔軟な設計を意識してプログラムを作成していきたい。
