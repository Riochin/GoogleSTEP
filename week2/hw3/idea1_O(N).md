# 考えたアルゴリズム１

## 作戦名：キュートに詰めよう
- 計算量：O(N) (無慈悲)
  - リスト内を検索するのにO(N)の計算量がかかるため
- キュー（FIFO）から着想を得たが、いつの間にか`head`がなくなり`tail`のみになっていた。

## 具体的なアルゴリズム（メモ書きレベル）
- HashMap<String URL, String Webページ>

に加えて、

- String[X] URLQue
    - Xは定数
    - Xは保存するキャッシュ数を表す
- // int head = 0 ←いらないと気づいた
- int tail = 1

という変数もそれぞれ用意する。

- キャッシュにnewURLを登録する（String newURL, String newWebName）
    - for url in URLQue:
        - i~~f newURL== urls~~
            - ~~return~~
    - tail==X: #キャッシュ容量を超過
        - tail=0 # 古いところに上書き
    - map.delete（URLQue[tail]）
    - map.put（newURL, newWebName）
    - URLQue[tail] = newURL

これ、URLQueの1番目とかにアクセスしたら【いちばん古い】と言えなくね

1,2,3,4

👈古い

1にアクセス

1,2,3,4

5にアクセス

5,2,3,4 （1<ほんじゃまた…）

⬆️こまる

1,2,3,4

👈古い

でまた何回も1にアクセスしたとき

1,2,3,4,1,1,1,1,1（容量いっぱい）

⬆️こうなるのもメモリの無駄遣いで良くない…

1,2,3,4

1にアクセス！

【詰める処理】

2,3,4,1

⬆️こうなるのが理想

ちなみに詰めるとしたら

1,2,3,4

2< アクセスされました

一旦、既にある1を0にする

1,0,3,4

X個のそれぞれを1つずつ前に、

0,3,4,1

0見つけたら2代入してループ終わり

2,3,4,1

こう…？

Xが定数なら、これは定数回ループしてるから計算量圧迫しない…？

- 配列内にnewがあるか確認
- 詰める処理

で定数分のループが発生