# 🧠 考えたアルゴリズム
## 🏷️ 作戦名
## キューピー（queue.py）

--- 

## 🎯 目的・問題の要点
- Webページのキャッシュ（URL,Webページ名）を保管するデータ構造を考える
- キャッシュ容量に到達した時は、一番最新アクセスが古いページから消す

---

## 💡 アルゴリズムの概要
### データ構造
- データ構造のクラス`Cache`は、
  - `HashMap`
  - `Page`をノードとしてもつ連結リスト
  の2つをかけ合わせて構成され、


- `HashMap map`は
  - key: url
  - value: Node
- のそれぞれを持ち、実際のキャッシュメモリとして利用する

- `Page`は
  - `Page prev`
  - `Page next`
  - `String url`
  - `String name`
- それぞれを持ち、
  - `Page old`
  - `Page new`
- を更新することで最古・最新のアクセス履歴を記録する

### メソッド
- `Cache`がもつメソッド
  - moveToNew(Page)
    - いちどアクセスされたページが再び最新に行く時に使用
    - `removePage(page)`→`addToNew(page)`で
実行
  - removePage(Page)
    - ページを削除する際に使用
    - 前後のPage同士を結び付ける作業を行う
  - addToNew(Page)
    - 履歴にないページにアクセスされた際に使用
    - 既存の`new`と引数のPageを結び付ける
    - `new`を置き換える

---

## 🔁 処理手順（ざっくり）

もちろん、以下のように簡潔にまとめられます：

---

- `access_page(url, contents)`
  * すでにあるページならリスト内の位置を先頭に移動
  * なければ新規ノードを作成し、先頭に追加
  * キャッシュが満杯なら末尾の古いノードを削除

- ✅ `get_pages()`
  * 先頭から順に `url` をリストに追加
  * そのリストを返す

---

## ⏱️ 計算量

* **時間計算量**：O(1)
* **空間計算量**：O(1)

---

## ⚠️ 注意点

* データが空のときうまく動作するか

---

## 🧪 テスト例（簡単に）

| 入力                               | 出力                     | 補足              |
| -------------------------------- | ---------------------- | --------------- |
| `["a", "b", "c", "d"]`           | `["d", "c", "b", "a"]` | 通常ケース（順番にアクセス）  |
| `["a", "b", "a", "b"]`           | `["b", "a"]`           | 同じものを何度もアクセス    |
| `["a", "b", "c", "d", "e"]`（N=4） | `["e", "d", "c", "b"]` | 境界ケース（キャッシュ溢れる） |

---
